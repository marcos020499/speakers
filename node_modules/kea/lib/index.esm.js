import { createSelector } from 'reselect';
import { applyMiddleware, compose, createStore } from 'redux';
import { useRef, useEffect, createElement, useMemo, createContext, useContext } from 'react';
import { connect as connect$1, useSelector } from 'react-redux';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function addConnection(logic, otherLogic) {
  if (!otherLogic.connections || Object.keys(otherLogic.connections).length === 0) {
    return;
  }

  if (logic.connections[otherLogic.pathString]) {
    return;
  }

  Object.keys(otherLogic.connections).forEach(function (path) {
    if (!logic.connections[path]) {
      logic.connections[path] = otherLogic.connections[path];
    }
  });
}

function createConnect(logic, input) {
  if (!input.connect) {
    return;
  }

  var props = logic.props || {};
  var connect = typeof input.connect === 'function' ? input.connect(props) : input.connect;
  var connectLogic = Array.isArray(connect) ? connect : connect.logic;

  if (connectLogic) {
    for (var _iterator = connectLogic, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var otherLogic = _ref;

      if (otherLogic._isKea) {
        otherLogic = otherLogic(props);
      }

      addConnection(logic, otherLogic);
    }

    if (Array.isArray(connect)) {
      return;
    }
  }

  if (connect.actions) {
    var response = deconstructMapping(connect.actions);
    response.forEach(function (_ref2) {
      var otherLogic = _ref2[0],
          from = _ref2[1],
          to = _ref2[2];

      if (process.env.NODE_ENV !== 'production') {
        if (typeof otherLogic !== 'function' && typeof otherLogic !== 'object') {
          throw new Error("[KEA] Logic \"" + logic.pathString + "\" can not connect to " + typeof otherLogic + " to request action \"" + from + "\"");
        }
      }

      if (otherLogic._isKea) {
        otherLogic = otherLogic(props);
      }

      if (otherLogic._isKeaBuild) {
        addConnection(logic, otherLogic);
        logic.actionCreators[to] = otherLogic.actionCreators[from];
      } else {
        logic.actionCreators[to] = otherLogic[from];
      }

      if (process.env.NODE_ENV !== 'production') {
        if (typeof logic.actionCreators[to] === 'undefined') {
          throw new Error("[KEA] Logic \"" + logic.pathString + "\", connecting to action \"" + from + "\" returns 'undefined'");
        }
      }
    });
  }

  if (connect.values || connect.props) {
    var _response = deconstructMapping(connect.values || connect.props);

    _response.forEach(function (_ref3) {
      var otherLogic = _ref3[0],
          from = _ref3[1],
          to = _ref3[2];

      if (process.env.NODE_ENV !== 'production') {
        if (typeof otherLogic !== 'function' && typeof otherLogic !== 'object') {
          throw new Error("[KEA] Logic \"" + logic.pathString + "\" can not connect to " + typeof otherLogic + " to request prop \"" + from + "\"");
        }
      }

      if (otherLogic._isKea) {
        otherLogic = otherLogic(props);
      }

      if (otherLogic._isKeaBuild) {
        addConnection(logic, otherLogic);
        logic.selectors[to] = from === '*' ? otherLogic.selector : otherLogic.selectors[from];

        if (from !== '*' && typeof otherLogic.propTypes[from] !== 'undefined') {
          logic.propTypes[to] = otherLogic.propTypes[from];
        }
      } else if (typeof otherLogic === 'function') {
        logic.selectors[to] = from === '*' ? otherLogic : function (state, props) {
          var values = otherLogic(state, props);
          return values && values[from];
        };
      }

      if (process.env.NODE_ENV !== 'production') {
        if (typeof logic.selectors[to] === 'undefined') {
          throw new Error("[KEA] Logic \"" + logic.pathString + "\", connecting to prop \"" + from + "\" returns 'undefined'");
        }
      }
    });
  }
}
function deconstructMapping(mapping) {
  if (mapping.length % 2 === 1) {
    console.error(mapping);
    throw new Error("[KEA] Uneven mapping given to connect");
  }

  var response = [];

  for (var i = 0; i < mapping.length; i += 2) {
    var logic = mapping[i];
    var array = mapping[i + 1];

    if (!Array.isArray(array)) {
      console.error(mapping);
      throw new Error('[KEA] Invalid mapping given to connect. Make sure every second element is an array!');
    }

    for (var j = 0; j < array.length; j++) {
      if (array[j].includes(' as ')) {
        var parts = array[j].split(' as ');
        response.push([logic, parts[0], parts[1]]);
      } else {
        response.push([logic, array[j], array[j]]);
      }
    }
  }

  return response;
}

function createConstants(logic, input) {
  if (!input.constants) {
    return;
  }

  var constants = convertConstants(typeof input.constants === 'function' ? input.constants(logic) : input.constants);
  Object.assign(logic.constants, constants);
}
function convertConstants(constants) {
  if (Array.isArray(constants)) {
    var response = {};

    for (var _iterator = constants, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var value = _ref;
      response[value] = value;
    }

    return response;
  }

  return constants;
}

var isObject = function isObject(item) {
  return typeof item === 'object' && !Array.isArray(item) && item !== null;
};

function createAction(type, payloadCreator) {
  var action = function action() {
    return {
      type: type,
      payload: typeof payloadCreator === 'function' ? payloadCreator.apply(void 0, arguments) : isObject(payloadCreator) ? payloadCreator : {
        value: payloadCreator
      }
    };
  };

  action.toString = function () {
    return type;
  };

  action._isKeaAction = true;
  return action;
}

var toSpaces = function toSpaces(key) {
  return key.replace(/(?:^|\.?)([A-Z])/g, function (x, y) {
    return ' ' + y.toLowerCase();
  }).replace(/^ /, '');
};

function createActionCreators(logic, input) {
  if (!input.actions) {
    return;
  }

  var payloadCreators = typeof input.actions === 'function' ? input.actions(logic) : input.actions;
  Object.keys(payloadCreators).forEach(function (key) {
    if (typeof payloadCreators[key] === 'function' && payloadCreators[key]._isKeaAction) {
      logic.actionCreators[key] = payloadCreators[key];
    } else {
      logic.actionCreators[key] = createAction(createActionType(key, logic.pathString), payloadCreators[key]);
    }
  });
}
function createActionType(key, pathString) {
  return toSpaces(key) + " (" + pathString + ")";
}

function createActions(logic, input) {
  Object.keys(logic.actionCreators).forEach(function (key) {
    var actionCreator = logic.actionCreators[key];
    var type = actionCreator.toString();

    logic.actions[key] = function () {
      var builtAction = actionCreator.apply(void 0, arguments);
      getContext().run.heap.push({
        type: 'action',
        action: builtAction,
        logic: logic
      });

      try {
        return getContext().store.dispatch(builtAction);
      } finally {
        getContext().run.heap.pop();
      }
    };

    logic.actions[key].toString = function () {
      return type;
    };

    logic.actionKeys[type] = key;
    logic.actionTypes[key] = type;
  });
}

function createDefaults(logic, input) {
  var _getContext = getContext(),
      defaults = _getContext.input.defaults;

  if (defaults) {
    assignContextDefaults(logic, defaults);
  }

  if (input.defaults) {
    assignInputDefaults(logic, input);
  }
}

function assignContextDefaults(logic, defaults) {
  var _getContext2 = getContext(),
      flatDefaults = _getContext2.options.flatDefaults;

  if (flatDefaults) {
    if (defaults[logic.pathString]) {
      Object.assign(logic.defaults, defaults[logic.pathString]);
    }
  } else {
    for (var _iterator = logic.path, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var part = _ref;
      defaults = defaults[part.toString()];

      if (typeof defaults !== 'object') {
        return;
      }
    }
  }

  Object.assign(logic.defaults, defaults);
}

function assignInputDefaults(logic, input) {
  var defaults = {};
  var defaultsSelector = typeof input.defaults === 'function' ? input.defaults(logic) : input.defaults;

  if (typeof defaultsSelector === 'function') {
    defaults['*'] = defaultsSelector;
  } else {
    defaults = defaultsSelector;
  }

  Object.assign(logic.defaults, defaults);
}

function createReducers(logic, input) {
  if (!input.reducers) {
    return;
  }

  var reducers = typeof input.reducers === 'function' ? input.reducers(logic) : input.reducers;
  var keys = Object.keys(reducers);

  var _loop = function _loop(i) {
    var key = keys[i];
    var object = reducers[key];
    var initialValue = void 0;
    var reducer = void 0;
    var type = void 0;
    var options = void 0;

    if (Array.isArray(object)) {
      initialValue = object[0];
      reducer = object[object.length - 1];
      type = typeof object[1] === 'function' ? object[1] : undefined;

      if (typeof object[object.length - 2] === 'object') {
        options = object[object.length - 2];
      }
    } else if (typeof object === 'function' || typeof object === 'object') {
      initialValue = null;
      reducer = object;
    } else {
      throw new Error("[KEA] Logic \"" + logic.pathString + "\" reducer \"" + key + "\" is set to unsupported value");
    }

    if (typeof logic.defaults[key] === 'undefined') {
      if (typeof logic.defaults['*'] === 'function') {
        logic.defaults[key] = function (state, props) {
          var v = logic.defaults['*'](state, props)[key];
          return typeof v === 'undefined' ? initialValue : typeof v === 'function' ? v(state, props) : v;
        };
      } else {
        logic.defaults[key] = initialValue;
      }
    }

    if (type) {
      logic.propTypes[key] = type;
    }

    if (!logic.reducerOptions[key]) {
      logic.reducerOptions[key] = {};
    }

    if (options) {
      Object.assign(logic.reducerOptions[key], options);
    }

    if (!logic.cache.reducers) {
      logic.cache.reducers = {};
    }

    if (!logic.cache.reducers[key] || options && options.replace) {
      logic.cache.reducers[key] = {
        functions: [],
        mapping: {}
      };
    }

    var cache = logic.cache.reducers[key];

    if (typeof reducer === 'function') {
      cache.functions.push(reducer);
    } else if (reducer) {
      var mappingKeys = Object.keys(reducer);

      for (var _i = 0; _i < mappingKeys.length; _i++) {
        var mappingKey = logic.actions[mappingKeys[_i]] ? logic.actions[mappingKeys[_i]].toString() : mappingKeys[_i];
        cache.mapping[mappingKey] = reducer[mappingKeys[_i]];
      }
    }

    var funReducer = createFunctionReducer(cache.functions, logic.defaults[key], key, logic);
    var mapReducer = createMappingReducer(cache.mapping, logic.defaults[key], key, logic);
    var newReducer = funReducer && mapReducer ? function (state, action, fullState) {
      return mapReducer(funReducer(state, action, fullState), action, fullState);
    } : mapReducer || funReducer;

    logic.reducers[key] = newReducer || function () {
      return logic.defaults[key];
    };
  };

  for (var i = 0; i < keys.length; i++) {
    _loop(i);
  }
}

function createFunctionReducer(functions, defaultValue, key, logic) {
  if (functions.length === 0) {
    return null;
  }

  return function (state, action, fullState) {
    if (typeof state === 'undefined') {
      state = getDefaultState(defaultValue, fullState, key, logic);
    }

    return functions.reduce(function (accumulatedState, reducer) {
      return reducer(accumulatedState, action, fullState);
    }, state);
  };
}

function createMappingReducer(mapping, defaultValue, key, logic) {
  if (Object.keys(mapping).length === 0) {
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    if (typeof mapping.undefined !== 'undefined') {
      throw new Error("[KEA] Logic \"" + logic.pathString + "\" reducer \"" + key + "\" is waiting for an action that is undefined: [" + Object.keys(mapping).join(', ') + "]");
    }
  }

  return function (state, action, fullState) {
    if (typeof state === 'undefined') {
      state = getDefaultState(defaultValue, fullState, key, logic);
    }

    if (mapping[action.type]) {
      return mapping[action.type](state, action.payload, action.meta);
    } else {
      return state;
    }
  };
}

function getDefaultState(defaultValue, fullState, key, logic) {
  if (typeof defaultValue === 'function') {
    if (fullState) {
      return defaultValue(fullState, logic.props);
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error("[KEA] Store not initialized and can't get default value of \"" + key + "\" in \"" + logic.pathString + "\"");
      }

      return undefined;
    }
  }

  return defaultValue;
}

var reservedKeys = {
  key: true,
  path: true,
  pathString: true,
  props: true,
  wrapper: true,
  wrap: true,
  build: true,
  mount: true,
  extend: true
};
function activatePlugin(pluginToActivate) {
  var plugin = typeof pluginToActivate === 'function' ? pluginToActivate() : pluginToActivate;

  var _getContext = getContext(),
      plugins = _getContext.plugins;

  var name = plugin.name;

  if (!name) {
    throw new Error('[KEA] Tried to activate a plugin without a name!');
  }

  if (plugins.activated.find(function (plugin) {
    return plugin.name === name;
  })) {
    throw new Error("[KEA] Tried to activate plugin \"" + name + "\", but it was already installed!");
  }

  plugins.activated.push(plugin);

  if (plugin.buildSteps) {
    for (var _i = 0, _Object$keys = Object.keys(plugin.buildSteps); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];

      if (plugins.buildSteps[key]) {
        console.error("[KEA] Plugin \"" + plugin.name + "\" redefines build step \"" + key + "\". Previously defined by " + (plugins.logicFields[key] || 'core'));
        plugins.buildSteps[key].push(plugin.buildSteps[key]);
      } else {
        plugins.buildSteps[key] = [plugin.buildSteps[key]];

        if (plugin.buildOrder && plugin.buildOrder[key]) {
          var _plugin$buildOrder$ke = plugin.buildOrder[key],
              after = _plugin$buildOrder$ke.after,
              before = _plugin$buildOrder$ke.before;
          var index = after || before ? plugins.buildOrder.indexOf(after || before) : -1;

          if (after && index >= 0) {
            plugins.buildOrder.splice(index + 1, 0, key);
          } else if (before && index >= 0) {
            plugins.buildOrder.splice(index, 0, key);
          } else {
            plugins.buildOrder.push(key);
          }
        } else {
          plugins.buildOrder.push(key);
        }
      }
    }
  }

  if (plugin.defaults) {
    var fields = Object.keys(typeof plugin.defaults === 'function' ? plugin.defaults() : plugin.defaults);

    for (var _i2 = 0, _fields = fields; _i2 < _fields.length; _i2++) {
      var _key = _fields[_i2];

      if (process.env.NODE_ENV !== 'production') {
        if (plugins.logicFields[_key] || reservedKeys[_key]) {
          console.error("[KEA] Plugin \"" + plugin.name + "\" redefines logic field \"" + _key + "\". Previously defined by " + (plugins.logicFields[_key] || 'core'));
        }
      }

      plugins.logicFields[_key] = plugin.name;
    }
  }

  if (plugin.events) {
    for (var _i3 = 0, _Object$keys2 = Object.keys(plugin.events); _i3 < _Object$keys2.length; _i3++) {
      var _key2 = _Object$keys2[_i3];

      if (!plugins.events[_key2]) {
        plugins.events[_key2] = [];
      }

      plugins.events[_key2].push(plugin.events[_key2]);
    }

    plugin.events.afterPlugin && plugin.events.afterPlugin();
  }
}
function runPlugins(key) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key3 = 1; _key3 < _len; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  var _getContext2 = getContext(),
      plugins = _getContext2.plugins,
      debug = _getContext2.options.debug;

  if (debug) {
    var _console;

    (_console = console).log.apply(_console, ["[KEA] Event: " + key].concat(args));
  }

  if (plugins && plugins.events[key]) {
    plugins.events[key].forEach(function (pluginFunction) {
      pluginFunction.apply(void 0, args);
    });
  }
}

var ATTACH_REDUCER = '@KEA/ATTACH_REDUCER';
var DETACH_REDUCER = '@KEA/DETACH_REDUCER';
var defaultState = {};
function initRootReducerTree(pathStart) {
  var _getContext = getContext(),
      _getContext$reducers = _getContext.reducers,
      tree = _getContext$reducers.tree,
      whitelist = _getContext$reducers.whitelist;

  if (!tree[pathStart]) {
    if (whitelist && !whitelist[pathStart]) {
      throw new Error("[KEA] Can not start reducer's path with \"" + pathStart + "\"! Please add it to the whitelist");
    }

    tree[pathStart] = {};
    regenerateRootReducer(pathStart);
  }
}
function keaReducer(pathStart) {
  if (pathStart === void 0) {
    pathStart = 'scenes';
  }

  var _getContext2 = getContext(),
      roots = _getContext2.reducers.roots;

  initRootReducerTree(pathStart);
  return function (state, action, fullState) {
    if (state === void 0) {
      state = defaultState;
    }

    return roots[pathStart] ? roots[pathStart](state, action, fullState) : state;
  };
}
function attachReducer(logic) {
  var path = logic.path,
      reducer = logic.reducer;

  var _getContext3 = getContext(),
      tree = _getContext3.reducers.tree,
      attachStrategy = _getContext3.options.attachStrategy,
      store = _getContext3.store;

  var pathStart = path[0].toString();
  initRootReducerTree(pathStart);
  var pointer = tree;

  for (var i = 0; i < path.length; i++) {
    var pathPart = path[i].toString();

    if (i === path.length - 1) {
      if (pointer[pathPart]) {
        if (i === 0 && typeof pointer[pathPart] === 'object' && Object.keys(pointer[pathPart]).length === 0) ; else if (typeof pointer[pathPart] !== 'function') {
          console.error("[KEA] Can not add reducer to \"" + path.join('.') + "\". There is something in the way:", pointer[pathPart]);
          return;
        }
      }

      pointer[pathPart] = reducer;
    } else {
      if (!pointer[pathPart]) {
        pointer[pathPart] = {};
      }

      pointer = pointer[pathPart];
    }
  }

  regenerateRootReducer(pathStart);

  if (attachStrategy === 'dispatch' || attachStrategy === 'replace') {
    runPlugins('beforeAttach', logic);

    if (attachStrategy === 'dispatch') {
      store && store.dispatch({
        type: ATTACH_REDUCER,
        payload: {
          path: path,
          reducer: reducer
        }
      });
    } else if (attachStrategy === 'replace') {
      store && store.replaceReducer(createReduxStoreReducer());
    }

    runPlugins('afterAttach', logic);
  }
}
function detachReducer(logic) {
  var path = logic.path;

  var _getContext4 = getContext(),
      tree = _getContext4.reducers.tree,
      detachStrategy = _getContext4.options.detachStrategy,
      store = _getContext4.store;

  var pathStart = path[0].toString();

  if (detachStrategy === 'persist') {
    return;
  }

  var detached = false;

  for (var i = path.length - 2; i >= 0; i--) {
    var pointerToHere = tree;

    for (var j = 0; j <= i; j++) {
      pointerToHere = pointerToHere && pointerToHere[path[j].toString()] || undefined;
    }

    if (pointerToHere) {
      if (Object.keys(pointerToHere).length === 0) ; else if (Object.keys(pointerToHere).length >= 1 && i === path.length - 2 && typeof pointerToHere[path[i + 1].toString()] === 'function') {
        delete pointerToHere[path[i + 1].toString()];
        detached = true;
      } else if (detached && Object.keys(pointerToHere).length >= 1 && i < path.length - 2 && Object.keys(pointerToHere[path[i + 1].toString()]).length === 0) {
        delete pointerToHere[path[i + 1].toString()];
      } else {
        break;
      }
    }
  }

  regenerateRootReducer(pathStart);

  if (detached) {
    if (detachStrategy === 'dispatch' || detachStrategy === 'replace') {
      runPlugins('beforeDetach', logic);

      if (detachStrategy === 'dispatch') {
        store && store.dispatch({
          type: DETACH_REDUCER,
          payload: {
            path: path
          }
        });
      } else if (detachStrategy === 'replace') {
        store && store.replaceReducer(createReduxStoreReducer());
      }

      runPlugins('afterDetach', logic);
    }
  }
}
function regenerateRootReducer(pathStart) {
  var _getContext5 = getContext(),
      _getContext5$reducers = _getContext5.reducers,
      tree = _getContext5$reducers.tree,
      roots = _getContext5$reducers.roots,
      whitelist = _getContext5$reducers.whitelist;

  if (pathStart !== 'kea' && !whitelist && typeof tree[pathStart] === 'object' && Object.keys(tree[pathStart]).length === 0) {
    delete roots[pathStart];
  } else {
    roots[pathStart] = recursiveCreateReducer(tree[pathStart]);
  }

  regenerateCombinedReducer();
}
function recursiveCreateReducer(treeNode) {
  if (typeof treeNode === 'function') {
    return treeNode;
  }

  var children = {};
  Object.keys(treeNode).forEach(function (key) {
    if (typeof treeNode[key] !== 'undefined') {
      children[key] = recursiveCreateReducer(treeNode[key]);
    }
  });

  if (Object.keys(children).length > 0) {
    return combineKeaReducers(children);
  } else {
    var emptyObj = {};
    return function () {
      return emptyObj;
    };
  }
}
function combineKeaReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  return function combination(state, action, fullState) {
    if (state === void 0) {
      state = {};
    }

    var stateChanged = Object.keys(state).length !== reducerKeys.length;
    var nextState = {};

    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];
      var reducer = reducers[key];
      var previousKeyState = state[key];
      var nextKeyState = reducer(previousKeyState, action, fullState || state);

      if (typeof nextKeyState === 'undefined') {
        throw new Error("[KEA] Reducer \"" + key + "\" returned undefined for action \"" + (action && action.type) + "\"");
      }

      nextState[key] = nextKeyState;
      stateChanged = stateChanged || nextKeyState !== previousKeyState;
    }

    return stateChanged ? nextState : state;
  };
}

function regenerateCombinedReducer() {
  var _getContext$reducers2 = getContext().reducers,
      redux = _getContext$reducers2.redux,
      roots = _getContext$reducers2.roots;
  var reducers = Object.assign({}, redux, roots);
  getContext().reducers.combined = combineKeaReducers(reducers);
}

function createReduxStoreReducer() {
  regenerateCombinedReducer();
  return function (state, action) {
    if (state === void 0) {
      state = defaultState;
    }

    return getContext().reducers.combined(state, action, state);
  };
}

var emptyObject = {};
function createReducer(logic, input) {
  if (!input.reducers) {
    return;
  }

  if (Object.keys(logic.reducers).length > 0) {
    logic.reducer = combineKeaReducers(logic.reducers);
  } else {
    logic.reducer = function () {
      return emptyObject;
    };
  }
}

function createReducerSelectors(logic, input) {
  if (!logic.reducer) {
    return;
  }

  logic.selector = function (state) {
    if (state === void 0) {
      state = getStoreState();
    }

    return pathSelector(logic.path, state);
  };

  Object.keys(logic.reducers).forEach(function (key) {
    logic.selectors[key] = createSelector(logic.selector, function (state) {
      return state[key];
    });
  });
}

function pathSelector(path, state) {
  return [state].concat(path).reduce(function (v, a) {
    if (a in v) {
      return v[a];
    }

    throw new Error("[KEA] Can not find path \"" + path.join('.') + "\" in the redux store.");
  });
}

function createSelectors(logic, input) {
  if (!input.selectors) {
    return;
  }

  var selectorInputs = typeof input.selectors === 'function' ? input.selectors(logic) : input.selectors;
  var selectorKeys = Object.keys(selectorInputs);
  var builtSelectors = {};
  selectorKeys.forEach(function (key) {
    logic.selectors[key] = function () {
      return builtSelectors[key].apply(builtSelectors, arguments);
    };
  });
  Object.keys(selectorInputs).forEach(function (key) {
    var _selectorInputs$key = selectorInputs[key],
        input = _selectorInputs$key[0],
        func = _selectorInputs$key[1],
        type = _selectorInputs$key[2];
    var args = input(logic.selectors);

    if (type) {
      logic.propTypes[key] = type;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (args.filter(function (a) {
        return typeof a !== 'function';
      }).length > 0) {
        var argTypes = args.map(function (a) {
          return typeof a;
        }).join(', ');
        var msg = "[KEA] Logic \"" + logic.pathString + "\", selector \"" + key + "\" has incorrect input: [" + argTypes + "].";
        throw new Error(msg);
      }
    }

    builtSelectors[key] = createSelector(args, func);

    logic.selectors[key] = function (state, props) {
      if (state === void 0) {
        state = getStoreState();
      }

      if (props === void 0) {
        props = logic.props;
      }

      return builtSelectors[key](state, props);
    };
  });
}

function createValues(logic, input) {
  if (Object.keys(logic.selectors).length === 0) {
    return;
  }

  var _loop = function _loop() {
    var key = _Object$keys[_i];

    if (!logic.values.hasOwnProperty(key)) {
      Object.defineProperty(logic.values, key, {
        get: function get() {
          return logic.selectors[key](getStoreState(), logic.props);
        },
        enumerable: true
      });
    }
  };

  for (var _i = 0, _Object$keys = Object.keys(logic.selectors); _i < _Object$keys.length; _i++) {
    _loop();
  }
}

function createEvents(logic, input) {
  if (input.events) {
    var events = typeof input.events === 'function' ? input.events(logic) : input.events;
    Object.keys(events).forEach(function (key) {
      var event = events[key];
      var newEvent = Array.isArray(event) ? function () {
        return event.forEach(function (e) {
          return e();
        });
      } : event;

      if (logic.events[key]) {
        var oldEvent = logic.events[key];

        logic.events[key] = function () {
          oldEvent && oldEvent();
          newEvent && newEvent();
        };
      } else if (newEvent) {
        logic.events[key] = newEvent;
      }
    });
  }
}

var corePlugin = {
  name: 'core',
  defaults: function defaults() {
    return {
      cache: {},
      connections: {},
      constants: {},
      actionCreators: {},
      actionKeys: {},
      actionTypes: {},
      actions: {},
      defaults: {},
      reducers: {},
      reducerOptions: {},
      reducer: undefined,
      selector: undefined,
      selectors: {},
      values: {},
      propTypes: {},
      events: {}
    };
  },
  buildSteps: {
    connect: createConnect,
    constants: createConstants,
    actionCreators: createActionCreators,
    actions: createActions,
    defaults: createDefaults,
    reducers: createReducers,
    reducer: createReducer,
    reducerSelectors: createReducerSelectors,
    selectors: createSelectors,
    values: createValues,
    events: createEvents
  }
};

var LISTENERS_BREAKPOINT = 'kea-listeners breakpoint broke';
var isBreakpoint = function isBreakpoint(error) {
  return error.message === LISTENERS_BREAKPOINT;
};
var listenersPlugin = {
  name: 'listeners',
  defaults: function defaults() {
    return {
      listeners: undefined,
      sharedListeners: undefined
    };
  },
  buildOrder: {
    listeners: {
      before: 'events'
    },
    sharedListeners: {
      before: 'listeners'
    }
  },
  buildSteps: {
    listeners: function listeners(logic, input) {
      if (!input.listeners) {
        return;
      }

      logic.cache.listenerBreakpointCounter = {};

      var fakeLogic = _extends({}, logic);

      Object.defineProperty(fakeLogic, 'store', {
        get: function get() {
          return getContext().store;
        }
      });
      var newListeners = typeof input.listeners === 'function' ? input.listeners(fakeLogic) : input.listeners;
      logic.listeners = _extends({}, logic.listeners || {});

      var _loop = function _loop() {
        var actionKey = _Object$keys[_i];
        var listenerArray = Array.isArray(newListeners[actionKey]) ? newListeners[actionKey] : [newListeners[actionKey]];
        var key = actionKey;

        if (typeof logic.actions[key] !== 'undefined') {
          key = logic.actions[key].toString();
        }

        var start = logic.listeners[key] ? logic.listeners[key].length : 0;
        var listenerWrapperArray = listenerArray.map(function (listener, index) {
          var listenerKey = key + "/" + (start + index);
          return function (action, previousState) {
            var _getContext = getContext(),
                heap = _getContext.run.heap;

            heap.push({
              type: 'listener',
              logic: logic
            });
            var breakCounter = (fakeLogic.cache.listenerBreakpointCounter[listenerKey] || 0) + 1;
            fakeLogic.cache.listenerBreakpointCounter[listenerKey] = breakCounter;

            var throwIfCalled = function throwIfCalled() {
              if (fakeLogic.cache.listenerBreakpointCounter[listenerKey] !== breakCounter) {
                throw new Error(LISTENERS_BREAKPOINT);
              }
            };

            var breakpoint = function breakpoint(ms) {
              if (typeof ms !== 'undefined') {
                return new Promise(function (resolve) {
                  return setTimeout(resolve, ms);
                }).then(function () {
                  throwIfCalled();
                });
              } else {
                throwIfCalled();
              }
            };

            var response;

            try {
              response = listener(action.payload, breakpoint, action, previousState);

              if (response && response.then && typeof response.then === 'function') {
                return response["catch"](function (e) {
                  if (e.message !== LISTENERS_BREAKPOINT) {
                    throw e;
                  }
                });
              }
            } catch (e) {
              if (e.message !== LISTENERS_BREAKPOINT) {
                throw e;
              }
            } finally {
              heap.pop();
            }

            return response;
          };
        });

        if (logic.listeners[key]) {
          logic.listeners[key] = [].concat(logic.listeners[key], listenerWrapperArray);
        } else {
          logic.listeners[key] = listenerWrapperArray;
        }
      };

      for (var _i = 0, _Object$keys = Object.keys(newListeners); _i < _Object$keys.length; _i++) {
        _loop();
      }
    },
    sharedListeners: function sharedListeners(logic, input) {
      if (!input.sharedListeners) {
        return;
      }

      var fakeLogic = _extends({}, logic);

      Object.defineProperty(fakeLogic, 'store', {
        get: function get() {
          return getContext().store;
        }
      });
      var newSharedListeners = typeof input.sharedListeners === 'function' ? input.sharedListeners(fakeLogic) : input.sharedListeners;
      logic.sharedListeners = _extends({}, logic.sharedListeners || {}, {}, newSharedListeners);
    }
  },
  events: {
    afterPlugin: function afterPlugin() {
      setPluginContext('listeners', {
        byAction: {},
        byPath: {}
      });
    },
    beforeReduxStore: function beforeReduxStore(options) {
      options.middleware.push(function (store) {
        return function (next) {
          return function (action) {
            var previousState = store.getState();
            var response = next(action);

            var _getPluginContext = getPluginContext('listeners'),
                byAction = _getPluginContext.byAction;

            var listeners = byAction[action.type];

            if (listeners) {
              for (var _i2 = 0, _Object$values = Object.values(listeners); _i2 < _Object$values.length; _i2++) {
                var listenerArray = _Object$values[_i2];

                for (var _iterator = listenerArray, _isArray = Array.isArray(_iterator), _i3 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                  var _ref;

                  if (_isArray) {
                    if (_i3 >= _iterator.length) break;
                    _ref = _iterator[_i3++];
                  } else {
                    _i3 = _iterator.next();
                    if (_i3.done) break;
                    _ref = _i3.value;
                  }

                  var innerListener = _ref;
                  innerListener(action, previousState);
                }
              }
            }

            return response;
          };
        };
      });
    },
    afterMount: function afterMount(logic) {
      if (!logic.listeners) {
        return;
      }

      addListenersByPathString(logic.pathString, logic.listeners);
    },
    beforeUnmount: function beforeUnmount(logic) {
      if (!logic.listeners) {
        return;
      }

      removeListenersByPathString(logic.pathString, logic.listeners);

      if (logic.cache.listenerBreakpointCounter) {
        for (var _i4 = 0, _Object$keys2 = Object.keys(logic.cache.listenerBreakpointCounter); _i4 < _Object$keys2.length; _i4++) {
          var key = _Object$keys2[_i4];
          logic.cache.listenerBreakpointCounter[key] += 1;
        }
      }
    },
    beforeCloseContext: function beforeCloseContext() {
      setPluginContext('listeners', {
        byAction: {},
        byPath: {}
      });
    }
  }
};

function addListenersByPathString(pathString, listeners) {
  var _getPluginContext2 = getPluginContext('listeners'),
      byPath = _getPluginContext2.byPath,
      byAction = _getPluginContext2.byAction;

  byPath[pathString] = listeners;
  Object.entries(listeners).forEach(function (_ref2) {
    var action = _ref2[0],
        listener = _ref2[1];

    if (!byAction[action]) {
      byAction[action] = {};
    }

    byAction[action][pathString] = listener;
  });
}

function removeListenersByPathString(pathString, listeners) {
  var _getPluginContext3 = getPluginContext('listeners'),
      byPath = _getPluginContext3.byPath,
      byAction = _getPluginContext3.byAction;

  Object.keys(listeners).forEach(function (action) {
    delete byAction[action][pathString];

    if (Object.keys(byAction[action]).length === 0) {
      delete byAction[action];
    }
  });
  delete byPath[pathString];
}

var reduxDevToolsCompose = typeof window !== 'undefined' && window['__REDUX_DEVTOOLS_EXTENSION_COMPOSE__'] ? window['__REDUX_DEVTOOLS_EXTENSION_COMPOSE__'] : compose;

var defaultOptions = function defaultOptions() {
  return {
    paths: [],
    reducers: {},
    preloadedState: undefined,
    middleware: [],
    compose: reduxDevToolsCompose,
    enhancers: [],
    plugins: []
  };
};

function getStore(opts) {
  if (opts === void 0) {
    opts = {};
  }

  var context = getContext();

  if (!context) {
    console.error('[KEA] Can not create a store without being in a context');
    return;
  }

  if (context['__store']) {
    console.error('[KEA] Already attached to a store! Exiting. Please reset the context before requesing a store');
    return;
  }

  var options = Object.assign({}, defaultOptions(), opts);
  context.reducers.redux = Object.assign({}, options.reducers);
  runPlugins('beforeReduxStore', options);

  if (options.middleware.length > 0) {
    options.enhancers = [applyMiddleware.apply(void 0, options.middleware)].concat(options.enhancers);
  }

  var composeEnchancer = options.compose || compose;
  var finalCreateStore = composeEnchancer.apply(void 0, options.enhancers)(createStore);

  if (options.paths && options.paths.length > 0) {
    context.reducers.whitelist = {};
    options.paths.forEach(function (pathStart) {
      context.reducers.whitelist[pathStart] = true;
      initRootReducerTree(pathStart);
    });
  } else {
    initRootReducerTree('kea');
  }

  var store = finalCreateStore(createReduxStoreReducer(), Object.assign({}, options.preloadedState));
  context['__store'] = store;
  runPlugins('afterReduxStore', options, store);
  return store;
}

var context;
function getContext() {
  return context;
}
var getStoreState = function getStoreState() {
  return getContext().store.getState();
};
function setContext(newContext) {
  context = newContext;
}
function openContext(options, initial) {
  if (options === void 0) {
    options = {};
  }

  if (initial === void 0) {
    initial = false;
  }

  if (context) {
    console.error('[KEA] overwriting already opened context. This may lead to errors.');
  }

  var _options = options,
      plugins = _options.plugins,
      _options$createStore = _options.createStore,
      createStore = _options$createStore === void 0 ? true : _options$createStore,
      defaults = _options.defaults,
      skipPlugins = _options.skipPlugins,
      otherOptions = _objectWithoutPropertiesLoose(_options, ["plugins", "createStore", "defaults", "skipPlugins"]);

  var newContext = {
    plugins: {
      activated: [],
      buildOrder: [],
      buildSteps: {},
      events: {},
      logicFields: {},
      contexts: {}
    },
    input: {
      inlinePathCreators: new Map(),
      inlinePathCounter: 0,
      defaults: defaults || undefined
    },
    build: {
      cache: {},
      heap: []
    },
    mount: {
      counter: {},
      mounted: {}
    },
    run: {
      heap: []
    },
    react: {
      contexts: new WeakMap()
    },
    reducers: {
      tree: {},
      roots: {},
      redux: {},
      whitelist: false,
      combined: undefined
    },
    store: undefined,
    __store: undefined,
    options: _extends({
      debug: false,
      autoMount: false,
      autoConnect: true,
      proxyFields: true,
      flatDefaults: false,
      attachStrategy: 'dispatch',
      detachStrategy: 'dispatch'
    }, otherOptions)
  };
  Object.defineProperty(newContext, 'store', {
    get: function get() {
      var store = newContext['__store'];

      if (!store && createStore) {
        return getStore(typeof createStore === 'object' ? createStore : {});
      }

      return store;
    },
    set: function set(store) {
      newContext['__store'] = store;
    }
  });
  setContext(newContext);
  activatePlugin(corePlugin);

  if (!skipPlugins || skipPlugins.indexOf('listeners') === -1) {
    activatePlugin(listenersPlugin);
  }

  runPlugins('afterOpenContext', newContext, options);

  if (plugins) {
    for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var plugin = _ref;
      activatePlugin(plugin);
    }
  }

  if (!initial && createStore) {
    context.store;
  }

  return context;
}
function closeContext() {
  if (context) {
    runPlugins('beforeCloseContext', context);
  }

  context = undefined;
}
function resetContext(options, initial) {
  if (options === void 0) {
    options = {};
  }

  if (initial === void 0) {
    initial = false;
  }

  if (context) {
    closeContext();
  }

  return openContext(options, initial);
}
function getPluginContext(name) {
  var _getContext = getContext(),
      plugins = _getContext.plugins;

  if (!plugins.contexts[name]) {
    plugins.contexts[name] = {};
  }

  return plugins.contexts[name];
}
function setPluginContext(name, pluginContext) {
  var _getContext2 = getContext(),
      plugins = _getContext2.plugins;

  plugins.contexts[name] = pluginContext;
}

function mountLogic(logic, count) {
  if (count === void 0) {
    count = 1;
  }

  var _getContext = getContext(),
      _getContext$mount = _getContext.mount,
      counter = _getContext$mount.counter,
      mounted = _getContext$mount.mounted;

  var pathStrings = Object.keys(logic.connections).filter(function (k) {
    return k !== logic.pathString;
  }).concat([logic.pathString]);

  for (var _iterator = pathStrings, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var pathString = _ref;
    counter[pathString] = (counter[pathString] || 0) + count;

    if (counter[pathString] === count) {
      var connectedLogic = logic.connections[pathString];
      runPlugins('beforeMount', connectedLogic);
      connectedLogic.events.beforeMount && connectedLogic.events.beforeMount();
      mounted[pathString] = connectedLogic;

      if (connectedLogic.reducer) {
        attachReducer(connectedLogic);
      }

      runPlugins('afterMount', connectedLogic);
      connectedLogic.events.afterMount && connectedLogic.events.afterMount();
    }
  }
}
function unmountLogic(logic) {
  var _getContext2 = getContext(),
      _getContext2$mount = _getContext2.mount,
      counter = _getContext2$mount.counter,
      mounted = _getContext2$mount.mounted;

  var pathStrings = Object.keys(logic.connections).filter(function (k) {
    return k !== logic.pathString;
  }).concat([logic.pathString]).reverse();

  for (var _iterator2 = pathStrings, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
    var _ref2;

    if (_isArray2) {
      if (_i2 >= _iterator2.length) break;
      _ref2 = _iterator2[_i2++];
    } else {
      _i2 = _iterator2.next();
      if (_i2.done) break;
      _ref2 = _i2.value;
    }

    var pathString = _ref2;
    counter[pathString] = (counter[pathString] || 0) - 1;

    if (counter[pathString] === 0) {
      var connectedLogic = logic.connections[pathString];
      runPlugins('beforeUnmount', connectedLogic);
      connectedLogic.events.beforeUnmount && connectedLogic.events.beforeUnmount();
      delete mounted[pathString];
      delete counter[pathString];

      if (connectedLogic.reducer) {
        detachReducer(connectedLogic);
      }

      runPlugins('afterUnmount', connectedLogic);
      connectedLogic.events.afterUnmount && connectedLogic.events.afterUnmount();
      delete getContext().build.cache[pathString];
    }
  }
}

function getPathForInput(input, props) {
  var key = props && input.key ? input.key(props) : undefined;

  if (input.path) {
    return typeof input.path === 'function' ? input.path(key) : input.path;
  }

  var _getContext = getContext(),
      inlinePathCreators = _getContext.input.inlinePathCreators;

  var pathCreator = inlinePathCreators.get(input);

  if (pathCreator) {
    return pathCreator(key);
  }

  var count = (++getContext().input.inlinePathCounter).toString();

  if (input.key) {
    pathCreator = function pathCreator(key) {
      return ['kea', 'inline', count, key];
    };
  } else {
    pathCreator = function pathCreator() {
      return ['kea', 'inline', count];
    };
  }

  inlinePathCreators.set(input, pathCreator);
  return pathCreator(key);
}
function getPathStringForInput(input, props) {
  return getPathForInput(input, props).join('.');
}

function applyInputToLogic(logic, input) {
  runPlugins('beforeLogic', logic, input);

  var _getContext = getContext(),
      _getContext$plugins = _getContext.plugins,
      buildOrder = _getContext$plugins.buildOrder,
      buildSteps = _getContext$plugins.buildSteps;

  for (var _iterator = buildOrder, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var step = _ref;

    for (var _iterator2 = buildSteps[step], _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var func = _ref2;
      func(logic, input);
    }
  }

  runPlugins('afterLogic', logic, input);
  return logic;
}

function createBlankLogic(_ref3) {
  var key = _ref3.key,
      path = _ref3.path,
      props = _ref3.props,
      wrapper = _ref3.wrapper;
  var logic = {
    _isKeaBuild: true,
    key: key,
    path: path,
    pathString: path.join('.'),
    props: props,
    wrapper: wrapper,
    extend: function extend(input) {
      return applyInputToLogic(logic, input);
    },
    mount: function mount(callback) {
      mountLogic(logic);

      if (callback) {
        var response = callback(logic);

        if (response && response.then && typeof response.then === 'function') {
          return response.then(function (value) {
            unmountLogic(logic);
            return value;
          });
        }

        unmountLogic(logic);
        return response;
      }

      return function () {
        return unmountLogic(logic);
      };
    }
  };
  return logic;
}

function setLogicDefaults(logic) {
  var _getContext2 = getContext(),
      plugins = _getContext2.plugins;

  for (var _iterator3 = plugins.activated, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
    var _ref4;

    if (_isArray3) {
      if (_i3 >= _iterator3.length) break;
      _ref4 = _iterator3[_i3++];
    } else {
      _i3 = _iterator3.next();
      if (_i3.done) break;
      _ref4 = _i3.value;
    }

    var plugin = _ref4;

    if (plugin.defaults) {
      var defaults = typeof plugin.defaults === 'function' ? plugin.defaults() : plugin.defaults;
      Object.assign(logic, defaults);
    }
  }
}

function buildLogic(_ref5) {
  var inputs = _ref5.inputs,
      path = _ref5.path,
      key = _ref5.key,
      props = _ref5.props,
      wrapper = _ref5.wrapper;
  var logic = createBlankLogic({
    key: key,
    path: path,
    props: props,
    wrapper: wrapper
  });
  setLogicDefaults(logic);

  var _getContext3 = getContext(),
      heap = _getContext3.build.heap;

  heap.push(logic);
  runPlugins('beforeBuild', logic, inputs);

  for (var _iterator4 = inputs, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
    var _ref6;

    if (_isArray4) {
      if (_i4 >= _iterator4.length) break;
      _ref6 = _iterator4[_i4++];
    } else {
      _i4 = _iterator4.next();
      if (_i4.done) break;
      _ref6 = _i4.value;
    }

    var input = _ref6;
    applyInputToLogic(logic, input);

    if (input.extend) {
      for (var _iterator5 = input.extend, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref7;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref7 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref7 = _i5.value;
        }

        var innerInput = _ref7;
        applyInputToLogic(logic, innerInput);
      }
    }
  }

  logic.connections[logic.pathString] = logic;
  runPlugins('afterBuild', logic, inputs);
  heap.pop();
  return logic;
}

function getBuiltLogic(inputs, props, wrapper, autoConnectInListener) {
  if (autoConnectInListener === void 0) {
    autoConnectInListener = true;
  }

  var input = inputs[0];
  var key = props && input.key ? input.key(props) : undefined;

  if (input.key && typeof key === 'undefined') {
    var _path = typeof input.path === 'function' ? input.path(key) : input.path;

    var _pathString = Array.isArray(_path) ? " " + _path.join('.') : '';

    throw new Error("[KEA] Must have key to build logic" + _pathString + ", got props: " + JSON.stringify(props));
  }

  var path = getPathForInput(input, props);
  var pathString = path.join('.');

  var _getContext4 = getContext(),
      _getContext4$build = _getContext4.build,
      buildHeap = _getContext4$build.heap,
      buildCache = _getContext4$build.cache,
      runHeap = _getContext4.run.heap,
      globalAutoConnect = _getContext4.options.autoConnect,
      mountCounter = _getContext4.mount.counter;

  if (!buildCache[pathString]) {
    buildCache[pathString] = buildLogic({
      inputs: inputs,
      path: path,
      key: key,
      props: props,
      wrapper: wrapper
    });
  } else {
    buildCache[pathString].props = props;
  }

  if (globalAutoConnect) {
    if (buildHeap.length > 0) {
      if (!buildHeap[buildHeap.length - 1].connections[pathString]) {
        addConnection(buildHeap[buildHeap.length - 1], buildCache[pathString]);
      }
    } else if (autoConnectInListener && runHeap.length > 0) {
      var heapElement = runHeap[runHeap.length - 1];
      var logic = heapElement.logic,
          type = heapElement.type;

      if (type === 'listener' && !logic.connections[pathString]) {
        addConnection(logic, buildCache[pathString]);
        mountLogic(buildCache[pathString], mountCounter[logic.pathString]);
      }
    }
  }

  return buildCache[pathString];
}

function wrapComponent(Component, wrapper) {
  var inputs = wrapper.inputs;
  var input = inputs[0];
  runPlugins('beforeWrapper', input, Component);
  injectActionsIntoClass(Component);
  var isUnmounting = {};
  var lastState = {};
  var createConnect = connect$1(function (state, props) {
    var pathString = getPathStringForInput(input, props);

    if (isUnmounting[pathString]) {
      return lastState[pathString];
    }

    var logic = wrapper.build(props);
    var resp = {};
    Object.entries(logic.selectors).forEach(function (_ref) {
      var key = _ref[0],
          selector = _ref[1];
      resp[key] = selector(state, props);
    });
    lastState[pathString] = resp;
    return resp;
  }, function (dispatch, props) {
    var logic = wrapper.build(props);
    var actions = Object.assign({}, props.actions, logic.actions);
    return {
      dispatch: dispatch,
      actions: actions
    };
  });
  var Connect = createConnect(Component);
  var injectPropTypes = !isStateless(Component);

  var Kea = function Kea(props) {
    var logic = wrapper.build(props);
    var pathString = useRef(logic.pathString);

    if (injectPropTypes && logic.propTypes) {
      injectPropTypes = false;
      Component.propTypes = Object.assign(Component.propTypes || {}, logic.propTypes);
    }

    var unmount = useRef();

    if (!unmount.current) {
      unmount.current = logic.mount();
    }

    useEffect(function () {
      return function () {
        isUnmounting[pathString.current] = true;
        unmount.current && unmount.current();
        delete isUnmounting[pathString.current];
        delete lastState[pathString.current];
      };
    }, []);

    if (pathString.current !== logic.pathString) {
      isUnmounting[pathString.current] = true;
      unmount.current();
      unmount.current = logic.mount();
      delete isUnmounting[pathString.current];
      delete lastState[pathString.current];
      pathString.current = logic.pathString;
    }

    runPlugins('beforeRender', logic, props);
    return createElement(Connect, props);
  };

  Kea._wrapper = wrapper;
  Kea._wrappedComponent = Component;
  runPlugins('afterWrapper', input, Component, Kea);
  return Kea;
}

function isStateless(Component) {
  return typeof Component === 'function' && !(Component.prototype && Component.prototype.isReactComponent);
}

function injectActionsIntoClass(Component) {
  if (!isStateless(Component)) {
    if (!Object.getOwnPropertyDescriptor(Component.prototype, 'actions')) {
      Object.defineProperty(Component.prototype, 'actions', {
        get: function actions() {
          return this.props.actions;
        }
      });
    }
  }
}

function proxyFieldToLogic(wrapper, key) {
  if (!wrapper.hasOwnProperty(key)) {
    Object.defineProperty(wrapper, key, {
      get: function get() {
        var _getContext = getContext(),
            mounted = _getContext.mount.mounted,
            buildHeap = _getContext.build.heap,
            runHeap = _getContext.run.heap;

        var path = getPathForInput(wrapper.inputs[0], {});
        var pathString = path.join('.');

        if (mounted[pathString] || buildHeap.length > 0 || runHeap.length > 0 || key === 'constants') {
          return wrapper.build()[key];
        } else {
          throw new Error("[KEA] Can not access \"" + key + "\" on logic \"" + pathString + "\" because it is not mounted!");
        }
      }
    });
  }
}
function proxyFields(wrapper) {
  var _getContext2 = getContext(),
      proxyFields = _getContext2.options.proxyFields,
      logicFields = _getContext2.plugins.logicFields;

  if (proxyFields) {
    var reservedProxiedKeys = ['path', 'pathString', 'props'];

    for (var _i = 0, _reservedProxiedKeys = reservedProxiedKeys; _i < _reservedProxiedKeys.length; _i++) {
      var key = _reservedProxiedKeys[_i];
      proxyFieldToLogic(wrapper, key);
    }

    for (var _i2 = 0, _Object$keys = Object.keys(logicFields); _i2 < _Object$keys.length; _i2++) {
      var _key = _Object$keys[_i2];
      proxyFieldToLogic(wrapper, _key);
    }
  }
}
function kea(input) {
  var wrapper = function wrapper(args) {
    if (typeof args === 'object' || typeof args === 'undefined') {
      return wrapper.build(args);
    }

    return wrapper.wrap(args);
  };

  wrapper._isKea = true;
  wrapper._isKeaWithKey = typeof input.key !== 'undefined';
  wrapper.inputs = [input];

  wrapper.wrap = function (Component) {
    return wrapComponent(Component, wrapper);
  };

  wrapper.build = function (props, autoConnectInListener) {
    if (props === void 0) {
      props = {};
    }

    if (autoConnectInListener === void 0) {
      autoConnectInListener = true;
    }

    return getBuiltLogic(wrapper.inputs, props, wrapper, autoConnectInListener);
  };

  wrapper.mount = function (callback) {
    return wrapper.build().mount(callback);
  };

  wrapper.extend = function (extendedInput) {
    wrapper.inputs.push(extendedInput);
    return wrapper;
  };

  if (!input.key) {
    proxyFields(wrapper);
    getContext().options.autoMount && wrapper.mount();
  }

  return wrapper;
}
function connect(input) {
  return kea({
    connect: input
  });
}

function useKea(input, deps) {
  if (deps === void 0) {
    deps = [];
  }

  return useMemo(function () {
    return kea(input);
  }, deps);
}
function useValues(logic) {
  var builtLogic = useMountedLogic(logic);
  return useMemo(function () {
    var response = {};

    var _loop = function _loop() {
      var key = _Object$keys[_i];
      Object.defineProperty(response, key, {
        get: function get() {
          return useSelector(builtLogic.selectors[key]);
        }
      });
    };

    for (var _i = 0, _Object$keys = Object.keys(builtLogic.selectors); _i < _Object$keys.length; _i++) {
      _loop();
    }

    return response;
  }, [builtLogic.pathString]);
}
function useAllValues(logic) {
  var builtLogic = useMountedLogic(logic);
  var response = {};

  for (var _i2 = 0, _Object$keys2 = Object.keys(builtLogic['selectors']); _i2 < _Object$keys2.length; _i2++) {
    var key = _Object$keys2[_i2];
    response[key] = useSelector(builtLogic['selectors'][key]);
  }

  return response;
}
function useActions(logic) {
  var builtLogic = useMountedLogic(logic);
  return builtLogic['actions'];
}
function isWrapper(toBeDetermined) {
  if (toBeDetermined._isKea) {
    return true;
  }

  return false;
}
var blankContext = createContext(undefined);
function useMountedLogic(logic) {
  var builtLogicContext = isWrapper(logic) ? getContext().react.contexts.get(logic) : null;
  var defaultBuiltLogic = useContext(builtLogicContext || blankContext);
  var builtLogic = isWrapper(logic) ? defaultBuiltLogic || logic.build() : logic;
  var unmount = useRef(undefined);

  if (!unmount.current) {
    unmount.current = builtLogic.mount();
  }

  var pathString = useRef(builtLogic.pathString);

  if (pathString.current !== builtLogic.pathString) {
    unmount.current();
    unmount.current = builtLogic.mount();
    pathString.current = builtLogic.pathString;
  }

  useEffect(function () {
    return function () {
      unmount.current && unmount.current();
    };
  }, []);
  return builtLogic;
}

function getOrCreateContextForLogicWrapper(logic) {
  var context = getContext().react.contexts.get(logic);

  if (!context) {
    context = createContext(undefined);
    getContext().react.contexts.set(logic, context);
  }

  return context;
}
function BindLogic(_ref) {
  var logic = _ref.logic,
      props = _ref.props,
      children = _ref.children;
  var LogicContext = getOrCreateContextForLogicWrapper(logic);
  var builtLogic = logic(props);
  useMountedLogic(builtLogic);
  return createElement(LogicContext.Provider, {
    value: builtLogic
  }, children);
}

var ATTACH_REDUCER$1 = ATTACH_REDUCER;
var DETACH_REDUCER$1 = DETACH_REDUCER;
resetContext({}, true);

export { ATTACH_REDUCER$1 as ATTACH_REDUCER, BindLogic, DETACH_REDUCER$1 as DETACH_REDUCER, activatePlugin, addConnection, closeContext, connect, createAction, getContext, getPluginContext, getStore, isBreakpoint, kea, keaReducer, openContext, resetContext, setPluginContext, useActions, useAllValues, useKea, useMountedLogic, useValues };
