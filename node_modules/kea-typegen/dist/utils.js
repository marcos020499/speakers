"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLogicPathString = exports.extractImportedActions = exports.cleanDuplicateAnyNodes = exports.getActionTypeCreator = exports.toSpaces = exports.getParameterDeclaration = exports.getTypeNodeForDefaultValue = exports.isKeaCall = exports.programFromSource = exports.sourceToSourceFile = exports.logicSourceToLogicType = void 0;
const ts = require("typescript");
const path = require("path");
const ts_clone_node_1 = require("@wessberg/ts-clone-node");
const visit_1 = require("./visit/visit");
const print_1 = require("./print/print");
function logicSourceToLogicType(logicSource, appOptions) {
    const program = programFromSource(logicSource);
    const [parsedLogic] = visit_1.visitProgram(program);
    return print_1.parsedLogicToTypeString(parsedLogic, appOptions);
}
exports.logicSourceToLogicType = logicSourceToLogicType;
function sourceToSourceFile(sourceCode, filename = 'logic.ts') {
    return ts.createSourceFile(filename, sourceCode, ts.ScriptTarget.ES5, true);
}
exports.sourceToSourceFile = sourceToSourceFile;
function programFromSource(sourceCode) {
    const options = {};
    const compilerHost = ts.createCompilerHost(options);
    compilerHost.getSourceFile = (fileName) => (fileName === 'logic.ts' ? sourceToSourceFile(sourceCode) : undefined);
    return ts.createProgram(['logic.ts'], options, compilerHost);
}
exports.programFromSource = programFromSource;
function isKeaCall(node, checker) {
    if (!ts.isIdentifier(node)) {
        return false;
    }
    if (!node.parent || !ts.isCallExpression(node.parent)) {
        return false;
    }
    if (!node.parent || !ts.isCallExpression(node.parent)) {
        return false;
    }
    const symbol = checker.getSymbolAtLocation(node);
    if (!symbol || symbol.getName() !== 'kea') {
        return false;
    }
    const input = node.parent.arguments[0];
    if (!ts.isObjectLiteralExpression(input)) {
        return false;
    }
    return true;
}
exports.isKeaCall = isKeaCall;
function getTypeNodeForDefaultValue(defaultValue, checker) {
    let typeNode;
    if (defaultValue) {
        if (ts.isAsExpression(defaultValue)) {
            typeNode = ts_clone_node_1.cloneNode(defaultValue.type);
            if (ts.isParenthesizedTypeNode(typeNode)) {
                typeNode = typeNode.type;
            }
        }
        else if ((defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.kind) === ts.SyntaxKind.TrueKeyword ||
            (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.kind) === ts.SyntaxKind.FalseKeyword) {
            typeNode = ts.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
        }
        else if (ts.isStringLiteralLike(defaultValue)) {
            typeNode = ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
        }
        else if (ts.isNumericLiteral(defaultValue)) {
            typeNode = ts.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
        }
        else if (ts.isArrayLiteralExpression(defaultValue) && defaultValue.elements.length === 0) {
            typeNode = ts.createArrayTypeNode(ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
        }
        else {
            typeNode = ts_clone_node_1.cloneNode(checker.typeToTypeNode(checker.getTypeAtLocation(defaultValue), undefined, undefined));
        }
    }
    else {
        typeNode = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
    }
    return typeNode;
}
exports.getTypeNodeForDefaultValue = getTypeNodeForDefaultValue;
function getParameterDeclaration(param) {
    return ts.createParameter(undefined, undefined, undefined, ts.createIdentifier(param.name.getText()), param.initializer || param.questionToken ? ts.createToken(ts.SyntaxKind.QuestionToken) : undefined, param.type || ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword), undefined);
}
exports.getParameterDeclaration = getParameterDeclaration;
exports.toSpaces = (key) => key.replace(/(?:^|\.?)([A-Z])/g, (x, y) => ' ' + y.toLowerCase()).replace(/^ /, '');
function getActionTypeCreator(parsedLogic) {
    return function (actionName) {
        return `${exports.toSpaces(actionName)} (${parsedLogic.pathString})`;
    };
}
exports.getActionTypeCreator = getActionTypeCreator;
function cleanDuplicateAnyNodes(reducers) {
    let newReducers = {};
    for (const reducer of reducers) {
        if (!newReducers[reducer.name] || ts.SyntaxKind[reducer.typeNode.kind] === 'â€ŒAnyKeyword') {
            newReducers[reducer.name] = reducer;
        }
    }
    return Object.values(newReducers);
}
exports.cleanDuplicateAnyNodes = cleanDuplicateAnyNodes;
function extractImportedActions(actionObjects, checker) {
    let extraActions = {};
    if (ts.isObjectLiteralExpression(actionObjects)) {
        for (const property of actionObjects.properties) {
            if (ts.isComputedPropertyName(property.name)) {
                let propertyExpression = property.name.expression;
                if (ts.isPropertyAccessExpression(propertyExpression)) {
                    const { name, expression } = propertyExpression;
                    const actionName = name.escapedText;
                    const nameSymbol = checker.getSymbolAtLocation(property.name);
                    const actionType = nameSymbol.escapedName;
                    if (ts.isPropertyAccessExpression(expression)) {
                        const symbol = checker.getSymbolAtLocation(expression.expression);
                        const symbolType = checker.getTypeOfSymbolAtLocation(symbol, expression.expression);
                        const actionCreatorsProperty = symbolType
                            .getProperties()
                            .find((p) => p.escapedName === 'actionCreators');
                        const actionCreators = actionCreatorsProperty === null || actionCreatorsProperty === void 0 ? void 0 : actionCreatorsProperty.valueDeclaration;
                        if (actionCreators &&
                            ts.isPropertySignature(actionCreators) &&
                            ts.isTypeLiteralNode(actionCreators.type)) {
                            const actionCreator = actionCreators.type.members.find((m) => { var _a; return ((_a = m.name) === null || _a === void 0 ? void 0 : _a.escapedText) === actionName; });
                            if (actionCreator &&
                                ts.isPropertySignature(actionCreator) &&
                                ts.isFunctionTypeNode(actionCreator.type)) {
                                extraActions[actionType] = ts_clone_node_1.cloneNode(actionCreator.type);
                            }
                        }
                    }
                }
            }
        }
    }
    return extraActions;
}
exports.extractImportedActions = extractImportedActions;
function getLogicPathString(appOptions, fileName) {
    let cwd = process.cwd();
    if (appOptions === null || appOptions === void 0 ? void 0 : appOptions.rootPath) {
        cwd = path.resolve(cwd, appOptions.rootPath);
    }
    const pathString = path
        .relative(cwd, fileName)
        .replace(/^.\//, '')
        .replace(/\.[jt]sx?$/, '')
        .replace(/\//g, '.');
    return pathString;
}
exports.getLogicPathString = getLogicPathString;
//# sourceMappingURL=utils.js.map