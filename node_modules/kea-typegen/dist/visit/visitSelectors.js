"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitSelectors = void 0;
const ts = require("typescript");
const ts_clone_node_1 = require("@wessberg/ts-clone-node");
const typescript_1 = require("typescript");
function visitSelectors(type, inputProperty, parsedLogic) {
    var _a, _b;
    const { checker } = parsedLogic;
    for (const property of type.getProperties()) {
        const name = property.getName();
        const value = property.valueDeclaration.initializer;
        if (ts.isArrayLiteralExpression(value) && value.elements.length > 1) {
            const inputFunction = value.elements[0];
            const inputFunctionTypeNode = checker.getTypeAtLocation(inputFunction);
            const selectorInputFunctionType = (_a = inputFunctionTypeNode.getCallSignatures()[0]) === null || _a === void 0 ? void 0 : _a.getReturnType();
            const selectorInputTypeNode = selectorInputFunctionType
                ? checker.typeToTypeNode(selectorInputFunctionType, inputFunction, typescript_1.NodeBuilderFlags.NoTruncation)
                : null;
            let functionNames = [];
            if (ts.isArrayLiteralExpression(inputFunction.body)) {
                functionNames = inputFunction.body.elements.map((element) => {
                    if (ts.isPropertyAccessExpression(element)) {
                        return element.name.getText();
                    }
                    else {
                        return null;
                    }
                });
            }
            let functionTypes = [];
            if (selectorInputTypeNode && ts.isTupleTypeNode(selectorInputTypeNode)) {
                let takenNames = {};
                functionTypes = selectorInputTypeNode.elementTypes.map((selectorTypeNode, index) => {
                    let name = functionNames[index] || 'arg';
                    takenNames[name] = (takenNames[name] || 0) + 1;
                    if (takenNames[name] > 1) {
                        name = `${name}${takenNames[name]}`;
                    }
                    return {
                        name,
                        type: ts.isFunctionTypeNode(selectorTypeNode)
                            ? ts_clone_node_1.cloneNode(selectorTypeNode.type)
                            : ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),
                    };
                });
            }
            const computedFunction = value.elements[1];
            const computedFunctionTypeNode = checker.getTypeAtLocation(computedFunction);
            const type = (_b = computedFunctionTypeNode.getCallSignatures()[0]) === null || _b === void 0 ? void 0 : _b.getReturnType();
            parsedLogic.selectors.push({
                name,
                typeNode: type
                    ? checker.typeToTypeNode(type, undefined, undefined)
                    : ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),
                functionTypes,
            });
        }
    }
}
exports.visitSelectors = visitSelectors;
//# sourceMappingURL=visitSelectors.js.map