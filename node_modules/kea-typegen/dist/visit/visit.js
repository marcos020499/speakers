"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVisit = exports.visitProgram = void 0;
const ts = require("typescript");
const path = require("path");
const utils_1 = require("../utils");
const visitActions_1 = require("./visitActions");
const visitReducers_1 = require("./visitReducers");
const visitSelectors_1 = require("./visitSelectors");
const visitLoaders_1 = require("./visitLoaders");
const visitConnect_1 = require("./visitConnect");
const visitWindowValues_1 = require("./visitWindowValues");
const visitProps_1 = require("./visitProps");
const visitKey_1 = require("./visitKey");
const visitPath_1 = require("./visitPath");
const visitListeners_1 = require("./visitListeners");
const visitConstants_1 = require("./visitConstants");
const visitEvents_1 = require("./visitEvents");
const visitDefaults_1 = require("./visitDefaults");
const visitSharedListeners_1 = require("./visitSharedListeners");
const visitFunctions = {
    actions: visitActions_1.visitActions,
    connect: visitConnect_1.visitConnect,
    constants: visitConstants_1.visitConstants,
    defaults: visitDefaults_1.visitDefaults,
    events: visitEvents_1.visitEvents,
    key: visitKey_1.visitKey,
    listeners: visitListeners_1.visitListeners,
    loaders: visitLoaders_1.visitLoaders,
    path: visitPath_1.visitPath,
    props: visitProps_1.visitProps,
    reducers: visitReducers_1.visitReducers,
    selectors: visitSelectors_1.visitSelectors,
    sharedListeners: visitSharedListeners_1.visitSharedListeners,
    windowValues: visitWindowValues_1.visitWindowValues,
};
function visitProgram(program, appOptions) {
    const checker = program.getTypeChecker();
    const parsedLogics = [];
    for (const sourceFile of program.getSourceFiles()) {
        if (!sourceFile.isDeclarationFile && !sourceFile.fileName.endsWith('Type.ts')) {
            if (appOptions === null || appOptions === void 0 ? void 0 : appOptions.verbose) {
                appOptions.log(`-> Visiting: ${path.relative(process.cwd(), sourceFile.fileName)}`);
            }
            ts.forEachChild(sourceFile, createVisit(checker, parsedLogics, sourceFile, appOptions));
        }
    }
    return parsedLogics;
}
exports.visitProgram = visitProgram;
function createVisit(checker, parsedLogics, sourceFile, appOptions) {
    return function visit(node) {
        var _a, _b;
        if (!utils_1.isKeaCall(node, checker)) {
            ts.forEachChild(node, visit);
            return;
        }
        let logicName = 'logic';
        if (ts.isCallExpression(node.parent) && ts.isVariableDeclaration(node.parent.parent)) {
            logicName = node.parent.parent.name.getText();
        }
        const logicTypeName = `${logicName}Type`;
        let logicTypeArguments = [];
        const keaTypeArguments = ts.isCallExpression(node.parent) ? node.parent.typeArguments : [];
        const keaTypeArgument = keaTypeArguments === null || keaTypeArguments === void 0 ? void 0 : keaTypeArguments[0];
        if (((_a = keaTypeArgument === null || keaTypeArgument === void 0 ? void 0 : keaTypeArgument.typeName) === null || _a === void 0 ? void 0 : _a.escapedText) === logicTypeName) {
            if (keaTypeArgument.typeArguments && keaTypeArgument.typeArguments.length > 0) {
                logicTypeArguments = keaTypeArgument.typeArguments.map((a) => a.getFullText());
            }
        }
        const pathString = utils_1.getLogicPathString(appOptions, sourceFile.fileName);
        const parsedLogic = {
            checker,
            logicName,
            logicTypeArguments: logicTypeArguments,
            fileName: sourceFile.fileName,
            actions: [],
            reducers: [],
            selectors: [],
            constants: [],
            listeners: [],
            sharedListeners: [],
            events: {},
            extraActions: {},
            keyType: undefined,
            propsType: undefined,
            path: pathString.split('.'),
            pathString: pathString,
        };
        const input = node.parent.arguments[0];
        for (const inputProperty of input.properties) {
            const symbol = checker.getSymbolAtLocation(inputProperty.name);
            if (!symbol) {
                continue;
            }
            const name = symbol.getName();
            let type = checker.getTypeOfSymbolAtLocation(symbol, symbol.valueDeclaration);
            let typeNode = type ? checker.typeToTypeNode(type, undefined, undefined) : null;
            if (typeNode && ts.isFunctionTypeNode(typeNode)) {
                type = type.getCallSignatures()[0].getReturnType();
            }
            (_b = visitFunctions[name]) === null || _b === void 0 ? void 0 : _b.call(visitFunctions, type, inputProperty, parsedLogic);
        }
        parsedLogics.push(parsedLogic);
    };
}
exports.createVisit = createVisit;
//# sourceMappingURL=visit.js.map