"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitActions = void 0;
const ts = require("typescript");
const ts_clone_node_1 = require("@wessberg/ts-clone-node");
function visitActions(type, inputProperty, parsedLogic) {
    const { checker } = parsedLogic;
    const properties = checker.getPropertiesOfType(type);
    for (const property of properties) {
        const name = property.getName();
        const type = checker.getTypeOfSymbolAtLocation(property, property.valueDeclaration);
        const typeNode = checker.typeToTypeNode(type, undefined, undefined);
        const signature = type.getCallSignatures()[0];
        let returnTypeNode;
        let parameters;
        if (ts.isFunctionTypeNode(typeNode)) {
            parameters = signature.getDeclaration().parameters.map((param) => {
                return ts.createParameter(undefined, undefined, undefined, ts.createIdentifier(param.name.getText()), param.initializer || param.questionToken ? ts.createToken(ts.SyntaxKind.QuestionToken) : undefined, param.type ? ts_clone_node_1.cloneNode(param.type) : ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword), undefined);
            });
            returnTypeNode = ts_clone_node_1.cloneNode(checker.typeToTypeNode(signature.getReturnType(), undefined, undefined));
        }
        else {
            returnTypeNode = ts.createTypeLiteralNode([
                ts.createPropertySignature(undefined, ts.createIdentifier('value'), undefined, typeNode, undefined),
            ]);
        }
        parsedLogic.actions.push({ name, parameters, returnTypeNode });
    }
}
exports.visitActions = visitActions;
//# sourceMappingURL=visitActions.js.map