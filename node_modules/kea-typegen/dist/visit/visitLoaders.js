"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.visitLoaders = void 0;
const ts = require("typescript");
const utils_1 = require("../utils");
function visitLoaders(type, inputProperty, parsedLogic) {
    var _a;
    const { checker } = parsedLogic;
    for (const property of type.getProperties()) {
        const loaderName = property.getName();
        const value = property.valueDeclaration.initializer;
        let defaultValue;
        let objectLiteral;
        if (ts.isArrayLiteralExpression(value)) {
            defaultValue = value.elements[0];
            objectLiteral = value.elements[1];
        }
        else if (ts.isObjectLiteralExpression(value)) {
            defaultValue = (_a = value.properties.find((property) => { var _a; return ((_a = checker.getSymbolAtLocation(property.name)) === null || _a === void 0 ? void 0 : _a.getName()) === '__default'; })) === null || _a === void 0 ? void 0 : _a.initializer;
            objectLiteral = value;
        }
        const typeNode = utils_1.getTypeNodeForDefaultValue(defaultValue, checker);
        parsedLogic.reducers.push({ name: loaderName, typeNode });
        parsedLogic.reducers.push({
            name: `${loaderName}Loading`,
            typeNode: ts.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword),
        });
        if (objectLiteral) {
            ;
            (objectLiteral.properties || []).forEach((property) => {
                var _a, _b;
                const loaderActionName = (_a = checker.getSymbolAtLocation(property.name)) === null || _a === void 0 ? void 0 : _a.getName();
                if (loaderActionName === '__default') {
                    return;
                }
                const func = property.initializer;
                if (!ts.isFunctionLike(func)) {
                    return;
                }
                const param = func.parameters ? func.parameters[0] : null;
                const parameters = param ? [utils_1.getParameterDeclaration(param)] : [];
                if (!parsedLogic.actions.find(({ name }) => name === `${loaderActionName}`)) {
                    const returnTypeNode = (param === null || param === void 0 ? void 0 : param.type) || ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
                    parsedLogic.actions.push({ name: `${loaderActionName}`, parameters, returnTypeNode });
                }
                if (!parsedLogic.actions.find(({ name }) => name === `${loaderActionName}Success`)) {
                    let returnTypeNode = (func === null || func === void 0 ? void 0 : func.type) || typeNode || ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);
                    if (ts.isTypeReferenceNode(returnTypeNode) &&
                        returnTypeNode.getSourceFile() &&
                        returnTypeNode.typeName.getText() === 'Promise') {
                        returnTypeNode = (_b = returnTypeNode.typeArguments) === null || _b === void 0 ? void 0 : _b[0];
                    }
                    const successParameters = [
                        ts.createParameter(undefined, undefined, undefined, ts.createIdentifier(loaderName), undefined, returnTypeNode, undefined),
                    ];
                    const successReturnTypeNode = ts.createTypeLiteralNode([
                        ts.createPropertySignature(undefined, ts.createIdentifier(loaderName), undefined, returnTypeNode, undefined),
                    ]);
                    parsedLogic.actions.push({
                        name: `${loaderActionName}Success`,
                        parameters: successParameters,
                        returnTypeNode: successReturnTypeNode,
                    });
                }
                if (!parsedLogic.actions.find(({ name }) => name === `${loaderActionName}Failure`)) {
                    const failureParameters = [
                        ts.createParameter(undefined, undefined, undefined, ts.createIdentifier('error'), undefined, ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword), undefined),
                    ];
                    const failureReturnTypeNode = ts.createTypeLiteralNode([
                        ts.createPropertySignature(undefined, ts.createIdentifier('error'), undefined, ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword), undefined),
                    ]);
                    parsedLogic.actions.push({
                        name: `${loaderActionName}Failure`,
                        parameters: failureParameters,
                        returnTypeNode: failureReturnTypeNode,
                    });
                }
            });
        }
    }
}
exports.visitLoaders = visitLoaders;
//# sourceMappingURL=visitLoaders.js.map