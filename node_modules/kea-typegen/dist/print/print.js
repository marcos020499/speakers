"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printLogicType = exports.parsedLogicToTypeString = exports.printToFiles = void 0;
const ts = require("typescript");
const fs = require("fs");
const path = require("path");
const prettier = require("prettier");
const printActions_1 = require("./printActions");
const printReducers_1 = require("./printReducers");
const printReducer_1 = require("./printReducer");
const printSelector_1 = require("./printSelector");
const printSelectors_1 = require("./printSelectors");
const printValues_1 = require("./printValues");
const printInternalSelectorTypes_1 = require("./printInternalSelectorTypes");
const printActionKeys_1 = require("./printActionKeys");
const printActionTypes_1 = require("./printActionTypes");
const printInternalReducerActions_1 = require("./printInternalReducerActions");
const printActionCreators_1 = require("./printActionCreators");
const printProps_1 = require("./printProps");
const printKey_1 = require("./printKey");
const printDefaults_1 = require("./printDefaults");
const printConstants_1 = require("./printConstants");
const printReducerOptions_1 = require("./printReducerOptions");
const printEvents_1 = require("./printEvents");
const printSharedListeners_1 = require("./printSharedListeners");
const printListeners_1 = require("./printListeners");
function runThroughPrettier(sourceText, filePath) {
    const options = prettier.resolveConfig.sync(filePath);
    if (options) {
        try {
            return prettier.format(sourceText, Object.assign(Object.assign({}, options), { filepath: filePath }));
        }
        catch (e) {
            console.error(`!! Prettier: Error formatting "${filePath}"`);
            console.error(e.message);
            return sourceText;
        }
    }
    else {
        return sourceText;
    }
}
function printToFiles(appOptions, parsedLogics) {
    const { log } = appOptions;
    const groupedByFile = {};
    parsedLogics.forEach((parsedLogic) => {
        if (!groupedByFile[parsedLogic.fileName]) {
            groupedByFile[parsedLogic.fileName] = [];
        }
        groupedByFile[parsedLogic.fileName].push(parsedLogic);
    });
    let writtenFiles = 0;
    let filesToWrite = 0;
    Object.entries(groupedByFile).forEach(([fileName, parsedLogics]) => {
        let typeFileName = fileName.replace(/\.[tj]sx?$/, 'Type.ts');
        if (appOptions.rootPath && appOptions.typesPath) {
            const relativePathFromRoot = path.relative(appOptions.rootPath, typeFileName);
            typeFileName = path.resolve(appOptions.typesPath, relativePathFromRoot);
        }
        const output = parsedLogics
            .map((l) => runThroughPrettier(parsedLogicToTypeString(l, appOptions), typeFileName))
            .join('\n\n');
        const requiredKeys = ['Logic'];
        if (parsedLogics.find((l) => l.sharedListeners.length > 0)) {
            requiredKeys.push('BreakPointFunction');
        }
        const finalOutput = [
            '// Auto-generated with kea-typegen. DO NOT EDIT!',
            `import { ${requiredKeys.join(', ')} } from 'kea'`,
            output,
        ].join('\n\n');
        let existingOutput;
        try {
            existingOutput = fs.readFileSync(typeFileName);
        }
        catch (error) { }
        if ((existingOutput === null || existingOutput === void 0 ? void 0 : existingOutput.toString()) !== finalOutput) {
            filesToWrite += 1;
            if (appOptions.write) {
                fs.mkdirSync(path.dirname(typeFileName), { recursive: true });
                fs.writeFileSync(typeFileName, finalOutput);
                writtenFiles += 1;
                log(`!! Writing: ${path.relative(process.cwd(), typeFileName)}`);
            }
            else {
                log(`:${smiles[i++ % smiles.length]} Would write: ${path.relative(process.cwd(), typeFileName)}`);
            }
        }
        else {
            if (appOptions.verbose) {
                log(`-- Unchanged: ${path.relative(process.cwd(), typeFileName)}`);
            }
        }
    });
    if (filesToWrite > 0 || (appOptions.verbose && Object.keys(groupedByFile).length > 0)) {
        log('');
    }
    if (writtenFiles === 0) {
        if (appOptions.write) {
            log(`-> No changes in logicType.ts files needed`);
        }
        else if (filesToWrite > 0) {
            log(`-> Run "kea-typegen write" to save types to disk!`);
        }
    }
    else if (writtenFiles > 0) {
        log(`-> Wrote ${writtenFiles} file${writtenFiles === 1 ? '' : 's'}!`);
    }
    return { filesToWrite, writtenFiles };
}
exports.printToFiles = printToFiles;
function parsedLogicToTypeString(parsedLogic, appOptions) {
    const logicType = printLogicType(parsedLogic, appOptions);
    const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
    const sourceFile = ts.createSourceFile('logic.ts', '', ts.ScriptTarget.Latest, false, ts.ScriptKind.TS);
    return printer.printNode(ts.EmitHint.Unspecified, logicType, sourceFile);
}
exports.parsedLogicToTypeString = parsedLogicToTypeString;
function printLogicType(parsedLogic, appOptions) {
    const printProperty = (name, typeNode) => ts.createPropertySignature(undefined, ts.createIdentifier(name), undefined, typeNode, undefined);
    const addSelectorTypeHelp = parsedLogic.selectors.filter((s) => s.functionTypes.length > 0).length > 0;
    return ts.createInterfaceDeclaration(undefined, [ts.createModifier(ts.SyntaxKind.ExportKeyword)], ts.createIdentifier(`${parsedLogic.logicName}Type`), parsedLogic.logicTypeArguments.map((text) => ts.createTypeParameterDeclaration(ts.createIdentifier(text.trim()), undefined)), [
        ts.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
            ts.createExpressionWithTypeArguments(undefined, ts.createIdentifier('Logic')),
        ]),
    ], [
        printProperty('actionCreators', printActionCreators_1.printActionCreators(parsedLogic, appOptions)),
        printProperty('actionKeys', printActionKeys_1.printActionKeys(parsedLogic, appOptions)),
        printProperty('actionTypes', printActionTypes_1.printActionTypes(parsedLogic, appOptions)),
        printProperty('actions', printActions_1.printActions(parsedLogic, appOptions)),
        printProperty('constants', printConstants_1.printConstants(parsedLogic)),
        printProperty('defaults', printDefaults_1.printDefaults(parsedLogic)),
        printProperty('events', printEvents_1.printEvents(parsedLogic)),
        printProperty('key', printKey_1.printKey(parsedLogic)),
        printProperty('listeners', printListeners_1.printListeners(parsedLogic)),
        printProperty('path', ts.createTupleTypeNode(parsedLogic.path.map((p) => ts.createLiteralTypeNode(ts.createStringLiteral(p))))),
        printProperty('pathString', ts.createStringLiteral(parsedLogic.pathString)),
        printProperty('props', printProps_1.printProps(parsedLogic)),
        printProperty('reducer', printReducer_1.printReducer(parsedLogic)),
        printProperty('reducerOptions', printReducerOptions_1.printReducerOptions(parsedLogic)),
        printProperty('reducers', printReducers_1.printReducers(parsedLogic)),
        printProperty('selector', printSelector_1.printSelector(parsedLogic)),
        printProperty('selectors', printSelectors_1.printSelectors(parsedLogic)),
        printProperty('sharedListeners', printSharedListeners_1.printSharedListeners(parsedLogic)),
        printProperty('values', printValues_1.printValues(parsedLogic)),
        printProperty('_isKea', ts.createTrue()),
        printProperty('_isKeaWithKey', parsedLogic.keyType ? ts.createTrue() : ts.createFalse()),
        addSelectorTypeHelp
            ? printProperty('__keaTypeGenInternalSelectorTypes', printInternalSelectorTypes_1.printInternalSelectorTypes(parsedLogic))
            : null,
        Object.keys(parsedLogic.extraActions).length > 0
            ? printProperty('__keaTypeGenInternalReducerActions', printInternalReducerActions_1.printInternalReducerActions(parsedLogic))
            : null,
    ].filter((a) => a));
}
exports.printLogicType = printLogicType;
let i = 0;
const smiles = ['/', ']', '[', ')', '(', '\\', 'D', '|', 'O'];
//# sourceMappingURL=print.js.map